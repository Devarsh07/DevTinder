1) Ek middleware se dusre middleware jane ke liye humein next() function ko call karna hi padega.
2)If we use multiple Request Handlers in a single Middleware/routes then we have only send a response from one of the request handlers , we cant able to send multiple responses from the single middleware.
3) app.use("/route",rH1,rH2,rH3,rH4);where rH is a Request Handlers;
4)we can make array of any one , two , three or all in one array like and all give same results , below;
app.use("/route",rH1,[rH2,rH3],rH4) --(i)
app.use("/route",rH1,rH2,rH3,[rH4]) --(ii)
app.use("/route",[rH1,rH2,rH3,rH4]) --(iii)

here i,ii,iii all are giveing the same responses/results.

5)what is Middleware? is a funtion which perform any changes or action on the comming requests through a callback function.
6)What is Middlewares? Middlewares is chain of callback function(one after the other) which performs some changes on the requests comming from the client,
 - and after completeion of all functions the last callback functions sending the response . 
 And this last or the any one which send the respond is called the request handler function.
7)Request Handler function is the function which handled the request and then send the response as per the request received.
8) jahaan bhi request mein changes ho rhe hai or jahaan bhi next() samajh le wo middleware hai.
9)when we use app.use for middleware/route handler it mean its checked the given route only while the incomming route has some sub routes-
 - also its only checked the route used in app.use middleware.But in case of app.all the incomming routes must be same as route used-
 - in the app.all , aur ye dono hi all type of incomming request ko support karte hai bhale hi wo GET,PUT,PATCH ... ok.
10)adding the userAuth middleware only in /user/data Request Handler , bcoz the /user/login Request handler dont have to check -
 - that which user is authrized or not bcoz anybody can login to websites ok.
11) we cannot track en err above the err creation line since the js run line by line and also it is an single threaded , so-
 - only after the err created we can only track it or display its message ok.
12)Here we can track/catch the err or displaying the err by two methods like ,
i)first as we know app.use("/",()=>{}) always run bcoz of it a wild card any route must have "/" so its matches directly and-
 - run this wildcard request handler directly now since it matches and run directly so , ismein hum jo bhi likhenge wo humesha-
 - chalega , ok
ii)by using the try and catch block , jo bhi karna hai wo try mein likho and then catch karo err aur fir message or jo bhi karna-
 - karna chahte ho wo kardo, ok
13)suppose humne apna server run karwaya and uske baad hi database connection karwaya now think ki there is something happen shit-
 - jiske wajah se database to connect nhi ho paaya but server run hogya aur tumne ye notice bhi nhi kiya kyunki tumne dekha server to run ho gya chlo ab site par kaam karte hai-
- but ab tumhare site par multiple api's ki call ho rhi but wo saari call err show ho ri due to connection failed in database-
- now suppose ye api's call thousands mein ho to ye bahot hi bad hoga tumhare site ke liye and tumhare market mein banayi hui ijjat ke liye bhi-
-thats why hum ye sure karte hai pehle database connect ho jaaye and then server run ho ok.
14)whenever you are doing some DB operations must write the code in Try And catch block bcoz DB operations take some time or it may gives err and that err must ba catched ok.
15)We are converting the Schema in the model bcoz we have to create and update or do many operations on collections and that done by model of mongoDB-
- suppose there is a collection user and in this user there is one document in user so when i want to create one or more document based on the previous schema so -
- we have to create an instance of the Model and apply all the DB operation on this.
16)Models are fancy constructors compiled from Schema definitions. An instance of a model is called a document. Models are responsible for creating and reading documents from the underlying MongoDB database.
17)Model name "user" → Collection name "users" ok
18)"Express by default can't read the raw JSON string in the request body. That's why we use express.json() middleware — it parses the JSON string and converts it into a JavaScript object, which we can then access via req.body."
19)"Jo bhi request ke body mein JSON string data hai, wo JSON string data ko JavaScript object mein badalkar wapas req.body mein daal dega, and then we can fetch it using req.body" —
yehi exactly express.json() ka kaam hai.
20)whenevr we hit the route or call the api express got a req(request) and this request is in js object that is serve by express to us for our works.-
- and this request also got a request.body which is undefined for the express bcoz of express is unable to req.body in json string , and this req.body is in json string thats why-
- we use a middleware for conversion of json string to json object ok.so after using this middleware we have javascript object data in our req.body and previously req.body have data but it was undefined fro the express.
21)we use POST AND PUT to Update Or Create a data in database , but we can do these both things with also the help of GET-
- here what i want to say that , Ye post,put,get sirf operations mein kya difference hai ye batane ke liye banaye gye hai-
- suppose tum postman se ye POST api call kar rhe with json data in body ok now you must  handle this api with POST request handler of same Route-
- and this api will create a user document in users collection in you database , but you can do all these things with also use of  GET method-
- ab postman mein bhi tumhe GET se call karna with same api and , request handler bhi GET ka ho aur baaki sab like  code for extracting-
- body from req and save it to user document all are same. aur tumhara user create or update ho jayega from GET method also.ok
22)User.find({ email: "devarsh@gmail.com" }) means find all the documents in the users collection which have the email field value = "devarsh@gmail.com", ok
23)The conditions are cast to their respective SchemaTypes before the command is sent.

Note: conditions is optional, and if conditions is null or undefined, mongoose will send an empty findOne command to MongoDB, which will return an arbitrary document. If you're querying by _id, use findById() instead.

24) after performing operation of mongoDB on model User like find(),findById(),findOne()...etc all return array of Javascript Objects ok.
and in findById()  not take by object like {id} it only takes simple id , ok
25)if user of id is not present in database then all the query related to id's i.e findById(),findByIdAndDelete() ... are return null value ok.
26)any other field that you are passing from frontend but it was not in you real schema in backend then this not show any err-
- it directly ignored by mongodb.
27)✅ You can update any field except _id.
❌ _id cannot be updated using .findByIdAndUpdate() or any update operation.
28)learn about mongoose>API>model i.e,all queries ok